module FortuneTeller
  # The spending strategy being used when simulating with FortuneTeller
  class SpendingStrategy < TransformGenerator
    def resolution_transforms(state:)
      transforms = []
      reader = state_reader
      12.times do |i|
        date = determine_transform_date(state, i)
        data = reader.read(date)
        next unless data.strategy == :exact
        amount = data.amount.on(date) - determine_take_home_pay(state, i)
        transforms.push(gen_transform(date, amount)) if amount.positive?
      end
      transforms
    end

    private

    def gen_transform(date, amount)
      self.class::Transform.new(
        holder: :joint,
        date: date,
        withdrawal: amount
      )
    end

    def determine_transform_date(state, index)
      Date.new(state.from.year, (index + 1), 1)
    end

    def determine_take_home_pay(state, index)
      c = state.cashflow
      merged = state.class.cashflow_base
      merged.merge!(c[:primary][index]).merge!(c[:partner][index])
      merged.line_items[:take_home_pay]
    end

    # The transforms generated by job
    class Transform < FortuneTeller::TransformBase
      attr_reader :withdrawal
      def initialize(holder:, date:, withdrawal:)
        @withdrawal = withdrawal
        super(holder: holder, date: date)
      end

      def apply_to(state)
        withdrawn = 0
        state.accounts.reject { |_k, a| a.balance.zero? }.each do |k, a|
          a.pass_time(to: @date)
          withdrawal = [a.balance, (@withdrawal - withdrawn)].min
          next if withdrawal.zero?
          make_withdrawal(state, a.account_ref.holder, k, withdrawal)
          withdrawn += withdrawal
          break if withdrawn == @withdrawal
        end
      end

      private

      def make_withdrawal(state, holder, account, amount)
        state.apply_pretax_savings_withdrawal(
          date: @date,
          holder: holder,
          source: account,
          amount: amount
        )
      end
    end
  end
end
